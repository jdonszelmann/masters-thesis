% !TEX root = document.tex

\chapter{Why providing code exploration services is hard}
\label{chap:why-providing-code-exploration-services-is-hard}

%\todo{maybe merge with the previous chapter}

In chapter~\ref{chap:code-exploration-services}, we discussed what code exploration services are, and
concluded that few code exploration services are provided outside editors.
This seems strange because programmers spend a lot of time exploring code outside an editor, mainly online.
So why are there so few code exploration services?

Providing editor services is not a trivial task.
Most editors and \acp{IDE} are massive dedicated programs with years of developer work put in.
Even with all that work, most editors rely on users to provide language-specific plugins or
extensions to actually provide editor services.

Providing code exploration services, outside editors might not be much different.
There exists no standardized program that can provide code exploration services for websites, and



% Why are so few code exploration services currently provided?
% Requirement that they often need to be provided statically
% M x N problem for code exploration services just like editor services
% For editors the solution seems to be a standard that is both supported my many languages and many editors
% If we do things statically, it makes sense for things to generate a file which can then be interpreted to generate html/latex/any other output
% What kind of requirements does such a format have?
% What's the best format?

\section{The $m \times n$ problem for code exploration services}\label{sec:the-$m-times-n$-problem-for-code-exploration-services}

Similar to editor services, with code exploration services there also exists an $m \times n$ type problem.
There exist many programming languages, and many exploration environments.
In each exploration environment, users might expect that exploration works for more than just a single language.

This again raises the complicated question of responsibility.
Are language authors responsible to support every code exploration environment, or are code exploration environments
responsible for supporting every single programming language.

For editor services, the solution to the $m \times n$ problem is a sort of common standard that many languages can provide,
and many editors can interpret.
For example, \ac{LSP} or \ac{AESI}.

Neither \ac{LSP} nor \ac{AESI} can solve the $m \times n$ problem for code exploration services.
The reason is that both rely on some sort of communication protocol.
In the case of \ac{LSP}, this is \ac{JSON-RPC}, and \ac{AESI} suggests using ZeroMQ or NanoMsg. \todo{REFERENCES}
When the users interacts with the editor, the editor makes some kind of request

However, in many exploration environments, such dynamic requests are not possible, or not feasible.
An example is \ac{PDF} documents.
Although, technically you could run javascript in \ac{PDF} documents, practically, \ac{PDF} viewers often have this
disabled as it poses a security risk.

That does not mean that no code exploration can be provided in \ac{PDF} documents.
All the information just has to be known in advance, and to be put in the right places in the \ac{PDF}.
For example, links to type definitions could be inserted in all the places where types are used, as long as that information
is known when the \ac{PDF} is generated.

The equivalent to a single standard communication protocol like \ac{LSP} provides, that can work statically, i.e.,
without requests to some kind of server during code exploration, is a kind of common data format.
Such a data format should be able to be generated from source code, and contains all the relevant metadata for that code.

\section{The requirements of a code metadata format}

